# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compiled code via Rcpp for Itoh's method of phase unwrapping
#' 
#' Called by [brcutpuw()] for fast phase unwrapping
#' 
#' @param nr number of rows in phase matrix
#' @param nc number of columns in phase matrix
#' @param phase phase matrix converted to vector
#' @param mask matrix of mask values converted to vector
#' @param dx wrapped phase differences in x direction
#' @param dy wrapped phase differences in y direction
#' @return a vector with the unwrapped phase
#' @details
#'   This is called by [brcutpuw()] through [idiffpuw()] 
#'   but is also user callable.
#'   Wrapped phase values and differences are divided by \code{2*pi} before input
#'   making the input values in the range [-1/2, 1/2).
#'   In [brcutpuw()] the mask indicates areas outside the interferogram area
#'   and lines of branch cuts
#' @seealso [brcutpuw()], [idiffpuw()]
#' @author M.L. Peck (mlpeck54 -at- gmail.com)  
id_dxy_uw <- function(nr, nc, phase, mask, dx, dy, uw) {
    .Call(`_zernike_id_dxy_uw`, nr, nc, phase, mask, dx, dy, uw)
}

#' Compiled code via Rcpp for Itoh's method of phase unwrapping
#' 
#' Called by [idiffpuw()] for fast phase unwrapping
#' 
#' @param nr number of rows in phase matrix
#' @param nc number of columns in phase matrix
#' @param phase phase matrix converted to vector
#' @return a vector with the unwrapped phase
#' @details
#'   This is called by [idiffpuw()] 
#'   but is also user callable.
#'   Wrapped phase values are divided by \code{2*pi} before input
#'   making the input values in the range [-1/2, 1/2).
#'   In [brcutpuw()] the mask indicates areas outside the interferogram area
#'   and lines of branch cuts
#' @seealso [brcutpuw()], [idiffpuw()]
#' @author M.L. Peck (mlpeck54 -at- gmail.com)  
id_uw <- function(nr, nc, phase) {
    .Call(`_zernike_id_uw`, nr, nc, phase)
}

lspsiC <- function(images, phases, wt) {
    .Call(`_zernike_lspsiC`, images, phases, wt)
}

aiapsiC <- function(images, phases_init, ptol, maxiter, trace) {
    .Call(`_zernike_aiapsiC`, images, phases_init, ptol, maxiter, trace)
}

gpcapsiC <- function(images, ptol, maxiter, trace) {
    .Call(`_zernike_gpcapsiC`, images, ptol, maxiter, trace)
}

#' Compiled code via Rcpp for quality guided phase unwrapping
#' 
#' Called by [qpuw()] for fast quality guided phase unwrapping
#' 
#' @param nr number of rows in phase matrix
#' @param nc number of columns in phase matrix
#' @param phase phase matrix converted to vector
#' @param qual quality matrix converted to vector
#' @return a vector with the unwrapped phase
#' @details
#'   This is called by [qpuw()] but is also user callable.
#'   Wrapped phase values are divided by \code{2*pi} before input
#'   making the input values in the range [-1/2, 1/2).
#' @seealso [qpuw()], [idiffpuw()]
#' @author M.L. Peck (mlpeck54 -at- gmail.com)  
#'   with valuable programming advice from Steve Koehler
q_uw <- function(nr, nc, phase, qual) {
    .Call(`_zernike_q_uw`, nr, nc, phase, qual)
}

readraw <- function(fname, channels) {
    .Call(`_zernike_readraw`, fname, channels)
}

rzernike <- function(rho, n, m) {
    .Call(`_zernike_rzernike`, rho, n, m)
}

res_frame <- function(pars, adata) {
    .Call(`_zernike_res_frame`, pars, adata)
}

jac_frame <- function(pars, adata) {
    .Call(`_zernike_jac_frame`, pars, adata)
}

pwrap <- function(phase) {
    .Call(`_zernike_pwrap`, phase)
}

tiltpsiC <- function(images, phases_init, coords, ptol, maxiter, trace) {
    .Call(`_zernike_tiltpsiC`, images, phases_init, coords, ptol, maxiter, trace)
}

zpmC <- function(rho, theta, maxorder = 12L) {
    .Call(`_zernike_zpmC`, rho, theta, maxorder)
}

zapmC <- function(rho, theta, maxorder = 12L) {
    .Call(`_zernike_zapmC`, rho, theta, maxorder)
}

zpmCP <- function(rho, theta, maxorder) {
    .Call(`_zernike_zpmCP`, rho, theta, maxorder)
}


#' Normalize matrix of Zernike polynomial values.
#'
#' Convert a matrix of Zernike polynomial values from
#' unit scaled to unit variance aka orthonormal form.
#'
#' @param uzpm matrix of Zernike polynomial values
#' @param maxorder the maximum radial order.
#'
#' @return matrix in orthonormal form.
#'
#' @details
#'  This is intended only for ISO/ANSI ordered matrices. The
#'  only check performed is that the number of columns in the
#'  matrix matches the expected number given by the argument
#'  `maxorder`.
#'  This is called by [gradzpm_cart()] and [zpm_cart()]
#'  if `unit_variance` is set to `true` in the respective
#'  function calls.
#' @md
norm_zpm <- function(uzpm, maxorder = 12L) {
    .Call(`_zernike_norm_zpm`, uzpm, maxorder)
}

#' Zernike polynomials and cartesian gradients
#'
#' Calculate Zernike polynomial values and Cartesian gradients in
#' ISO/ANSI sequence for a set of Cartesian coordinates.
#'
#' @param x a vector of x coordinates for points on a unit disk.
#' @param y a vector of y coordinates.
#' @param maxorder the maximum radial polynomial order (defaults to 12).
#' @param unit_variance logical: return with orthonormal scaling? (default `false`)
#' @param return_zpm logical: return Zernike polynomial matrix? (default `true`)
#'
#' @return a named list with the matrices `zm` (optional but returned by default), `dzdx`, `dzdy`.
#'
#' @references
#'   Anderson, T.B. (2018) Optics Express 26, #5, 18878
#'   <https://doi.org/10.1364/OE.26.018878> (open access)
#'
#' @details
#'  Uses the recurrence relations in the above publication to calculate Zernike
#'  polynomial values and their directional derivatives in Cartesian coordinates. These are
#'  known to be both efficient and numerically stable.
#'
#'  Columns are in ISO/ANSI sequence: for each radial order n >= 0 the azimuthal orders m are sequenced
#'  m = {-n, -(n-2), ..., (n-2), n}, with sine components for negative m and cosine for positive m. Note this
#'  is the opposite ordering from the extended Fringe set and the ordering of aberrations is quite different. 
#'  For example the two components of trefoil are in the 7th and 10th column while coma is in
#'  columns 8 and 9 (or 7 and 8 with 0-indexing). Note also that except for tilt and coma-like aberrations
#'  (m=1) non-axisymmetric aberrations will be separated.
#'
#'  All three matrices will have the same dimensions on return. Columns 0 and 1 of `dzdx` will be all 0,
#'  while columns 0 and 2 of `dzdy` are 0.
#'
#' @seealso [zpm()] uses the same recurrence relations for polar coordinates and extended
#'  Fringe set ordering, which is the more common indexing scheme for optical design/testing
#'  software.
#' @seealso [zpm_cart()] calculates and returns the Zernike polynomial values only.
#'
#' @examples
#'  rho <- seq(0.2, 1., length=5)
#'  theta <- seq(0, 1.6*pi, length=5)
#'  rt <- expand.grid(theta, rho)
#'  x <- c(0, rt[,2]*cos(rt[,1]))
#'  y <- c(0, rt[,2]*sin(rt[,1]))
#'  gzpm <- gradzpm_cart(x, y)
#'
#' @md
gradzpm_cart <- function(x, y, maxorder = 12L, unit_variance = FALSE, return_zpm = TRUE) {
    .Call(`_zernike_gradzpm_cart`, x, y, maxorder, unit_variance, return_zpm)
}

#' Zernike polynomials
#'
#' Calculate Zernike polynomial values in
#' ISO/ANSI sequence for a set of Cartesian coordinates.
#'
#' @param x a vector of x coordinates for points on a unit disk.
#' @param y a vector of y coordinates.
#' @param maxorder the maximum radial polynomial order (defaults to 12).
#' @param unit_variance logical: return with orthonormal scaling? (default `false`)
#'
#' @return a matrix of Zernike polynomial values evaluated at the input
#'  Cartesian coordinates and all radial and azimuthal orders from
#'  0 through `maxorder`.
#'
#' @details This is the same algorithm and essentially the same code as [gradzpm_cart()]
#'  except directional derivatives aren't calculated.
#' @md
zpm_cart <- function(x, y, maxorder = 12L, unit_variance = TRUE) {
    .Call(`_zernike_zpm_cart`, x, y, maxorder, unit_variance)
}

#' Zernike Annular polynomials
#'
#' Calculate approximate Zernike Annular polynomial values in
#' ISO/ANSI sequence for a set of Cartesian coordinates.
#'
#' @param x a vector of x coordinates for points on a unit disk.
#' @param y a vector of y coordinates.
#' @param maxorder the maximum radial polynomial order (defaults to 12).
#'
#' @return a matrix of approximate Zernike Annular polynomial values evaluated at the input
#'  Cartesian coordinates and all radial and azimuthal orders from
#'  0 through `maxorder`.
#'
#' @details Uses QR decomposition applied separately to each azimuthal order m to orthogonalize a matrix
#'  of Zernike polynomials. This closely approximates annular Zernikes for a large enough set of coordinates.
#'
#'  Note the coordinates must be uniformly spaced for this to produce the intended values.
#' @md
zapm_cart <- function(x, y, maxorder = 12L) {
    .Call(`_zernike_zapm_cart`, x, y, maxorder)
}

